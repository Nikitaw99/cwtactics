<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: logic/attack.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: logic/attack.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 *
 * @namespace
 */
cwt.Attack = {

  /**
   * Signal for units that cannot attack.
   *
   * @constant
   */
  FIRETYPE_NONE: 0,

  /**
   * Indirect fire type that can fire from range 2 to x.
   *
   * @constant
   */
  FIRETYPE_INDIRECT: 1,

  /**
   * Direct fire type that can fire from range 1 to 1.
   *
   * @constant
   */
  FIRETYPE_DIRECT: 2,

  /**
   * Ballistic fire type that can fire from range 1 to x.
   *
   * @constant
   */
  FIRETYPE_BALLISTIC: 3,

  /**
   * Calculates the targets of a battle unit. If `data` is given, then
   * the attack targets will be marked in this object.
   *
   * @param {cwt.Unit} unit
   * @param {number} x
   * @param {number} y
   * @param {cwt.SelectionMap=} data
   * @param {boolean=} markTiles
   * @return {boolean}
   */
  calculateTargets: function (unit, x, y, data, markTiles) {
    if (this.DEBUG) cwt.assert(unit instanceof cwt.Unit);
    if (this.DEBUG) cwt.assert(cwt.Map.isValidPosition(x, y));

    var markInData = (typeof data !== "undefined");
    var teamId = unit.owner.team;
    var attackSheet = unit.type.attack;

    if (markInData) data.setCenter(x, y, cwt.INACTIVE);

    // no battle unit ?
    if (typeof attackSheet === "undefined") return false;

    // a unit may does not have ammo but a weapon
    // that needs ammo to fire
    if (this.hasMainWeapon(unit) &amp;&amp; !this.hasSecondaryWeapon(unit) &amp;&amp;
      unit.type.ammo > 0 &amp;&amp;
      unit.ammo === 0) return false;

    var minR = 1;
    var maxR = 1;

    if (unit.type.attack.minrange) {
      minR = unit.type.attack.minrange;
      maxR = unit.type.attack.maxrange;
    }

    var lX;
    var hX;
    var lY = y - maxR;
    var hY = y + maxR;
    if (lY &lt; 0) lY = 0;
    if (hY >= cwt.Map.height) hY = cwt.Map.height - 1;
    for (; lY &lt;= hY; lY++) {

      var disY = Math.abs(lY - y);
      lX = x - maxR + disY;
      hX = x + maxR - disY;
      if (lX &lt; 0) lX = 0;
      if (hX >= cwt.Map.width) hX = cwt.Map.width - 1;
      for (; lX &lt;= hX; lX++) {
        var tile = cwt.Map.data[lX][lY];
        var dis = cwt.Map.getDistance(x, y, lX, lY);

        // if markTiles is true, then mark all tiles in range
        if (markTiles &amp;&amp; dis >= minR) {
          data.setValueAt(lX, lY, 1);
          continue;
        }

        // drop tile when hidden in fog
        if (tile.visionTurnOwner === 0) continue;

        if (dis >= minR) {
          var dmg = -1;

          var tUnit = tile.unit;
          if (tUnit &amp;&amp; tUnit.owner.team !== teamId) {

            dmg = this.getBaseDamageAgainst(unit, tUnit);
            if (dmg > 0) {

              // if mark tile is true, then mark them in the
              // selection map else return true
              if (markInData) data.setValueAt(lX, lY, dmg);
              else return true;
            }
          }

        }
      }
    }

    return false;
  },


  /**
   * Returns the fire type.
   */
  getFireType: function (unit) {
    if (!this.hasMainWeapon(unit) &amp;&amp; !this.hasSecondaryWeapon(unit)) {
      return cwt.Unit.FIRETYPE_NONE;
    }

    // main weapon decides fire type
    if (typeof unit.type.attack.minrange === "number") {
      var min = unit.type.attack.minrange;

      // min range of 1 means ballistic weapon
      if (min === 1) {
        return this.FIRETYPE_BALLISTIC;
      } else {
        return this.FIRETYPE_INDIRECT;
      }
    } else {
      return this.FIRETYPE_DIRECT;
    }
  },

  /**
   * Returns `true` if a given unit is an indirect firing
   * unit ( *e.g. artillery* ) else `false`.
   *
   * @return {boolean}
   */
  isIndirect: function (unit) {
    return unit.getFireType() === cwt.Attack.FIRETYPE_INDIRECT;
  },

  /**
   * Returns `true` if a given unit is an ballistic firing
   * unit ( *e.g. anti-tank-gun* ) else `false`.
   *
   * @return {boolean}
   */
  isBallistic: function (unit) {
    return unit.getFireType() === cwt.Attack.FIRETYPE_BALLISTIC;
  },

  /**
   * Returns true if the unit type has a main weapon else false.
   */
  hasMainWeapon: function (unit) {
    var attack = unit.type.attack;
    return (attack &amp;&amp; attack.main_wp);
  },

  /**
   * Returns true if the unit type has a secondary
   * weapon else false.
   */
  hasSecondaryWeapon: function (unit) {
    var attack = unit.type.attack;
    return (attack &amp;&amp; attack.sec_wp);
  },

  /**
   * Returns true if an attacker can use it's main weapon against a
   * defender. The distance won't be checked in case of indirect units.
   */
  canUseMainWeapon: function (attacker, defender) {
    var attack = attacker.type.attack;
    var tType = defender.type.ID;
    var v;

    // check_ ammo and main weapon availability against the defender type
    if (this.ammo > 0 &amp;&amp; attack.main_wp) {
      v = attack.main_wp[tType];
      if (v &amp;&amp; v > 0) {
        return true;
      }
    }

    return false;
  },

  /**
   * Returns true if an unit has targets in sight, else false.
   */
  hasTargets: function (unit, x, y, moved) {
    if (moved &amp;&amp; this.isIndirect(unit)) return false;

    return this.calculateTargets(unit, x, y);
  },

  /**
   * Returns the base damage of an attacker against a defender. If
   * the attacker cannot attack the defender then -1 will be returned.
   * This function recognizes the ammo usage of main weapons. If the
   * attacker cannot attack with his main weapon due low ammo then only
   * the secondary weapon will be checked.
   */
  getBaseDamageAgainst: function (attacker, defender, withMainWp) {
    var attack = attacker.type.attack;
    if (!attack) return -1;
    var tType = defender.type.ID;
    var v;

    if (typeof withMainWp === "undefined") withMainWp = true;

    // check_ main weapon
    if (withMainWp &amp;&amp; attacker.ammo > 0 &amp;&amp; attack.main_wp !== undefined) {
      v = attack.main_wp[tType];
      if (typeof v !== "undefined") return v;
    }

    // check_ secondary weapon
    if (attack.sec_wp !== undefined) {
      v = attack.sec_wp[tType];
      if (typeof v !== "undefined") return v;
    }

    return -1;
  },

  /**
   * Returns the battle damage against an other unit.
   */
  getBattleDamageAgainst: function (attacker, defender, luck, withMainWp, isCounter) {
    if (typeof isCounter === "undefined") isCounter = false;

    var BASE = this.getBaseDamageAgainst(attacker, defender, withMainWp);
    if (BASE === -1) return -1;

    var AHP = cwt.Unit.healthToPoints(attacker);
    var LUCK = parseInt((luck / 100) * 10, 10);
    var ACO = 100;
    if (isCounter) ACO += 0;

    var def = cwt.Map.searchUnit(defender,this.grabUnitTile_,null).type.defense;
    var DCO = 100;
    var DHP = cwt.Unit.healthToPoints(defender);
    var DTR = parseInt(def * 100 / 100, 10);

    var damage;
    if (cwt.Gameround.gameMode &lt;= cwt.Gameround.GAME_MODE_AW2) {
      damage = BASE * (ACO / 100 - (ACO / 100 * (DCO - 100) / 100)) * (AHP / 10);
    } else {
      damage = BASE * (ACO / 100 * DCO / 100) * (AHP / 10);
    }

    return parseInt(damage, 10);
  },

  /**
   * Declines when the attacker does not have targets in range.
   *
   * @param attId
   * @param defId
   * @param attLuckRatio
   * @param defLuckRatio
   */
  attack: function (attacker, defender, attLuckRatio, defLuckRatio) {
    if (this.DEBUG) cwt.assert(attacker instanceof cwt.Unit);
    if (this.DEBUG) cwt.assert(defender instanceof cwt.Unit);
    if (this.DEBUG) cwt.assert(attLuckRatio >= 0 &amp;&amp; attLuckRatio &lt;= 100);
    if (this.DEBUG) cwt.assert(defLuckRatio >= 0 &amp;&amp; defLuckRatio &lt;= 100);

    var indirectAttack = this.isIndirect(attacker);

    // **check_ firstCounter:** if first counter is active then the defender
    // attacks first. In this case swap attacker and defender.
    /*
     if (!indirectAttack &amp;&amp; controller.scriptedValue(defender.owner, "firstCounter", 0) === 1) {
     if (!model.battle_isIndirectUnit(defId)) {
     var tmp_ = defender;
     defender = attacker;
     attacker = tmp_;
     }
     }
     */

    var aSheets = attacker.type;
    var dSheets = defender.type;
    var attOwner = attacker.owner;
    var defOwner = defender.owner;
    var powerAtt = cwt.Unit.healthToPoints(defender);
    var powerCounterAtt = cwt.Unit.healthToPoints(attacker);
    var mainWpAttack = this.canUseMainWeapon(attacker, defender);
    var damage = this.getBattleDamageAgainst(attacker, defender, attLuckRatio, mainWpAttack, false);

    if (damage !== -1) {
      defender.takeDamage(damage);
      if (defender.hp &lt;= 0) {
        cwt.Map.searchUnit(defender, this.destroyAfterBattle_, null);
      }

      powerAtt -= cwt.Unit.healthToPoints(defender);

      if (mainWpAttack) attacker.ammo--;

      powerAtt = ( parseInt(powerAtt * 0.1 * dSheets.cost, 10) );
      cwt.CO.modifyStarPower(attOwner, parseInt(0.5 * powerAtt, 10));
      cwt.CO.modifyStarPower(defOwner, powerAtt);
    }

    // counter attack when defender survives and defender is an indirect attacking unit
    if (defender.hp > 0 &amp;&amp; !this.isIndirect(defender)) {
      mainWpAttack = this.canUseMainWeapon(defender, attacker);

      damage = this.getBattleDamageAgainst(defender, attacker, defLuckRatio, mainWpAttack, true);

      if (damage !== -1) {
        attacker.takeDamage(damage);
        if (attacker.hp &lt;= 0) {
          cwt.Map.searchUnit(attacker, this.destroyAfterBattle_, null);
        }

        powerCounterAtt -= cwt.Unit.healthToPoints(attacker);

        if (mainWpAttack) defender.ammo--;

        powerCounterAtt = ( parseInt(powerCounterAtt * 0.1 * aSheets.cost, 10) );
        cwt.CO.modifyStarPower(defOwner, parseInt(0.5 * powerCounterAtt, 10));
        cwt.CO.modifyStarPower(attOwner, powerCounterAtt);
      }
    }
  },

  grabUnitTile_: function (x, y) {
    return cwt.Map.data[x][y];
  },

  destroyAfterBattle_: function (x, y) {
    cwt.Lifecycle.destroyUnit(x, y, false);
  }
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="$base.html">base/$base</a></li></ul><h3>Classes</h3><ul><li><a href="cwt.Action.html">Action</a></li><li><a href="cwt.ActionData.html">ActionData</a></li><li><a href="cwt.CircularBuffer.html">CircularBuffer</a></li><li><a href="cwt.Config.html">Config</a></li><li><a href="cwt.GameState.html">GameState</a></li><li><a href="cwt.Input.html">Input</a></li><li><a href="cwt.InputData.html">InputData</a></li><li><a href="cwt.Layer.html">Layer</a></li><li><a href="cwt.LayeredCanvas.html">LayeredCanvas</a></li><li><a href="cwt.Matrix.html">Matrix</a></li><li><a href="cwt.MovetypeSheet.html">MovetypeSheet</a></li><li><a href="cwt.Pagination.html">Pagination</a></li><li><a href="cwt.Player.html">Player</a></li><li><a href="cwt.Position.html">Position</a></li><li><a href="cwt.Property.html">Property</a></li><li><a href="cwt.html#Sprite">Sprite</a></li><li><a href="cwt.Storage.html">Storage</a></li><li><a href="cwt.Tile.html">Tile</a></li><li><a href="cwt.TileVariantInfo.html">TileVariantInfo</a></li><li><a href="cwt.UIButtonGroup.html">UIButtonGroup</a></li><li><a href="cwt.UICheckboxField.html">UICheckboxField</a></li><li><a href="cwt.UICustomField.html">UICustomField</a></li><li><a href="cwt.UIField.html">UIField</a></li><li><a href="cwt.UIScreenLayout.html">UIScreenLayout</a></li><li><a href="cwt.Unit.html">Unit</a></li></ul><h3>Namespaces</h3><ul><li><a href="cwt.ActionStack.html">ActionStack</a></li><li><a href="cwt.Attack.html">Attack</a></li><li><a href="cwt.Cannon.html">Cannon</a></li><li><a href="cwt.Capture.html">Capture</a></li><li><a href="cwt.ClientEvents.html">ClientEvents</a></li><li><a href="cwt.CO.html">CO</a></li><li><a href="cwt.Cursor.html">Cursor</a></li><li><a href="cwt.Explode.html">Explode</a></li><li><a href="cwt.Factory.html">Factory</a></li><li><a href="cwt.FlowData.menu.html">menu</a></li><li><a href="cwt.Fog.html">Fog</a></li><li><a href="cwt.GameData.html">GameData</a></li><li><a href="cwt.Gameflow.html">Gameflow</a></li><li><a href="cwt.Gameround.html">Gameround</a></li><li><a href="cwt.Image.html">Image</a></li><li><a href="cwt.Join.html">Join</a></li><li><a href="cwt.Laser.html">Laser</a></li><li><a href="cwt.Lifecycle.html">Lifecycle</a></li><li><a href="cwt.Loading.html">Loading</a></li><li><a href="cwt.Localization.html">Localization</a></li><li><a href="cwt.Map.html">Map</a></li><li><a href="cwt.MapRenderer.html">MapRenderer</a></li><li><a href="cwt.Maps.html">Maps</a></li><li><a href="cwt.Move.html">Move</a></li><li><a href="cwt.Network.html">Network</a></li><li><a href="cwt.Options.html">Options</a></li><li><a href="cwt.Relationship.html">Relationship</a></li><li><a href="cwt.Screen.html">Screen</a></li><li><a href="cwt.Silo.html">Silo</a></li><li><a href="cwt.Supply.html">Supply</a></li><li><a href="cwt.Team.html">Team</a></li><li><a href="cwt.Transport.html">Transport</a></li><li><a href="cwt.Turn.html">Turn</a></li><li><a href="cwt.Weather.html">Weather</a></li></ul><h3>Global</h3><ul><li><a href="global.html#background">background</a></li><li><a href="global.html#check_">check_</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#getContext">getContext</a></li><li><a href="global.html#getLayer">getLayer</a></li><li><a href="global.html#isValidSheet">isValidSheet</a></li><li><a href="global.html#registerSheet">registerSheet</a></li><li><a href="global.html#renderLayer">renderLayer</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetValues">resetValues</a></li><li><a href="global.html#sheets">sheets</a></li><li><a href="global.html#types">types</a></li><li><a href="global.html#validator_">validator_</a></li><li><a href="global.html#value[2]">value[2]</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Fri May 16 2014 19:01:55 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
