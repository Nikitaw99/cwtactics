<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: model/map.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: model/map.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @namespace
 */
cwt.Map = {

  /**
   * Current width of the map.
   *
   * @type {Number}
   */
  width: 0,

  /**
   * Current height of the map.
   *
   * @type {Number}
   */
  height: 0,

  /**
   * All tiles of the map.
   *
   * @type {Array.&lt;Array.&lt;cwt.Tile>>}
   */
  data: (function () {
    var matrix = new cwt.Matrix(cwt.MAX_MAP_WIDTH, cwt.MAX_MAP_HEIGHT);
    for (var x = 0, xe = cwt.MAX_MAP_WIDTH; x &lt; xe; x++) {
      for (var y = 0, ye = cwt.MAX_MAP_HEIGHT; y &lt; ye; y++) {
        matrix.data[x][y] = new cwt.Tile();
      }
    }

    return matrix.data;
  })(),

  /**
   * Returns the distance of two positions.
   */
  getDistance: function (sx, sy, tx, ty) {
    if (this.DEBUG) cwt.assert(this.isValidPosition(sx, sy));
    if (this.DEBUG) cwt.assert(this.isValidPosition(tx, ty));

    return Math.abs(sx - tx) + Math.abs(sy - ty);
  },

  /**
   * Returns true if the given position (x,y) is valid on the current
   * active map, else false.
   */
  isValidPosition: function (x, y) {
    return ( x >= 0 &amp;&amp; y >= 0 &amp;&amp; x &lt; this.width &amp;&amp; y &lt; this.height );
  },

  /**
   *
   * @param property
   * @param cb
   * @param cbThis
   * @param arg
   */
  searchProperty: function (property, cb, cbThis, arg) {
    for (var x = 0, xe = this.width; x &lt; xe; x++) {
      for (var y = 0, ye = this.height; y &lt; ye; y++) {
        if (this.data[x][y].property === property) {
          cb.call(cbThis, x, y, property, arg);
        }
      }
    }
  },

  /**
   *
   * @param unit
   * @param cb
   * @param cbThis
   * @param {Object=} arg
   */
  searchUnit: function (unit, cb, cbThis, arg) {
    for (var x = 0, xe = this.width; x &lt; xe; x++) {
      for (var y = 0, ye = this.height; y &lt; ye; y++) {
        if (this.data[x][y].unit === unit) {
          return cb.call(cbThis, x, y, unit, arg);
        }
      }
    }
  },

  /**
   * Invokes a callback on all tiles in a given range at a position (x,y).
   */
  doInRange: function (x, y, range, cb, arg) {
    if (this.DEBUG) cwt.assert(this.isValidPosition(x, y));
    if (this.DEBUG) cwt.assert(typeof cb === "function");
    if (this.DEBUG) cwt.assert(range >= 0);

    var lX;
    var hX;
    var lY = y - range;
    var hY = y + range;
    if (lY &lt; 0) lY = 0;
    if (hY >= this.height) hY = this.height - 1;
    for (; lY &lt;= hY; lY++) {

      var disY = Math.abs(lY - y);
      lX = x - range + disY;
      hX = x + range - disY;
      if (lX &lt; 0) lX = 0;
      if (hX >= this.width) hX = this.width - 1;
      for (; lX &lt;= hX; lX++) {

        // invoke the callback on all tiles in range
        // if a callback returns `false` then the process will be stopped
        if (cb(lX, lY, this.data[lX][lY], arg, Math.abs(lX - x) + disY) === false) return;

      }
    }
  },

  $onSaveGame: function (data) {
    var that = cwt.Map;
    data.mpw = this.width;
    data.mph = this.height;
    data.map = [];
    data.prps = [];
    data.units = [];

    // generates ID map
    var mostIdsMap = {};
    var mostIdsMapCurIndex = 0;
    for (var x = 0, xe = that.width; x &lt; xe; x++) {

      data.map[x] = [];
      for (var y = 0, ye = that.height; y &lt; ye; y++) {
        var type = that.data[x][y].type.ID;

        // create number for type
        if (!mostIdsMap.hasOwnProperty(type)) {
          mostIdsMap[type] = mostIdsMapCurIndex;
          mostIdsMapCurIndex++;
        }

        data.map[x][y] = mostIdsMap[type];

        // save property
        var prop = that.data[x][y].property;
        if (prop) {
          data.prps.push([
            cwt.Property.getInstanceId(prop),
            x,
            y,
            prop.type.ID,
            prop.capturePoints,
            prop.owner.id
          ]);
        }

        // save unit
        var unit = that.data[x][y].unit;
        if (unit) {
          data.units.push([
            cwt.Unit.getInstanceId(unit),
            unit.type.ID,
            x,
            y,
            unit.hp,
            unit.ammo,
            unit.fuel,
            unit.loadedIn,
            unit.owner.id,
            unit.canAct,
            unit.hidden
          ]);
        }
      }
    }

    // generate type map
    data.typeMap = [];
    var typeKeys = Object.keys(mostIdsMap);
    for (var i = 0, e = typeKeys.length; i &lt; e; i++) {
      data.typeMap[mostIdsMap[typeKeys[i]]] = typeKeys[i];
    }
  },

  $onLoadGame: function (data, isSave) {
    var that = cwt.Map;
    
    var property;
    var unit;
    var player;

    that.width = data.mpw;
    that.height = data.mph;

    // map
    for (var x = 0, xe = that.width; x &lt; xe; x++) {
      for (var y = 0, ye = that.height; y &lt; ye; y++) {
        that.data[x][y].type = cwt.TileSheet.sheets[data.typeMap[data.map[x][y]]];
      }
    }

    // prepare properties
    for (var i = 0, e = cwt.Property.MULTITON_INSTANCES; i &lt; e; i++) {
      property = cwt.Property.getInstance(i, true);
      if (property) {
        property.owner = null;
        property.type = null;
        property.capturePoints = 20;
      }
    }

    // saved properties
    cwt.assert(Array.isArray(data.prps));
    for (var i = 0, e = data.prps.length; i &lt; e; i++) {
      var propData = data.prps[i];

      // check_ map data
      cwt.assert(propData[0] >= 0 &amp;&amp; propData[0] &lt; cwt.Property.MULTITON_INSTANCES);
      cwt.assert(propData[1] >= 0 &amp;&amp; propData[1] &lt; that.width);
      cwt.assert(propData[2] >= 0 &amp;&amp; propData[2] &lt; that.height);
      cwt.assert(cwt.PropertySheet.sheets.hasOwnProperty(propData[3]));
      cwt.assert(propData[5] >= -1 &amp;&amp; propData[5] &lt; cwt.Player.MULTITON_INSTANCES);

      //cwt.assert(
      //  (util.isString(propData[3]) &amp;&amp; !util.isUndefined(model.data_tileSheets[propData[3]].capturePoints)) ||
      //    typeof model.data_tileSheets[propData[3]].cannon !== "undefined" ||
      //    typeof model.data_tileSheets[propData[3]].laser !== "undefined" ||
      //    typeof model.data_tileSheets[propData[3]].rocketsilo !== "undefined"
      //);

      //cwt.assert((util.intRange(propData[4], 1, // capture points
      //  model.data_tileSheets[propData[3]].capturePoints)) ||
      // (util.intRange(propData[4], -99, -1)) ||
      //  typeof model.data_tileSheets[propData[3]].rocketsilo !== "undefined"
      //);

      // copy data into model
      property = cwt.Property.getInstance(propData[0]);
      property.type = cwt.PropertySheet.sheets[propData[3]];
      property.capturePoints = propData[4];
      property.owner = (propData[5] != cwt.INACTIVE)? cwt.Player.getInstance(propData[5]) : null;
      that.data[propData[1]][propData[2]].property = property;
    }

    // prepare units
    cwt.assert(Array.isArray(data.units));
    for (var i = 0, e = cwt.Unit.MULTITON_INSTANCES; i &lt; e; i++) {
      unit = cwt.Unit.getInstance(i, true);
      if (unit) {
        unit.owner = null;
      }
    }

    // saved units
    for (var i = 0, e = data.units.length; i &lt; e; i++) {
      var unitData = data.units[i];

      // check_ map data
      cwt.assert(unitData[0] >= 0 &amp;&amp; unitData[0] &lt; cwt.Unit.MULTITON_INSTANCES);
      cwt.assert(cwt.UnitSheet.sheets.hasOwnProperty(unitData[1]));
      cwt.assert(that.isValidPosition(unitData[2], unitData[3]));
      cwt.assert(unitData[4] >= 1 &amp;&amp; unitData[4] &lt;= 99);

      var type = cwt.UnitSheet.sheets[unitData[1]];
      cwt.assert(unitData[5] >= 0 &amp;&amp; unitData[5] &lt;= type.ammo);
      cwt.assert(unitData[6] >= 0 &amp;&amp; unitData[6] &lt;= type.fuel);
      cwt.assert(typeof unitData[7] === "number");
      cwt.assert(unitData[8] >= -1 &amp;&amp; unitData[8] &lt; cwt.Player.MULTITON_INSTANCES);
      cwt.assert(unitData.length &lt; 10 || typeof unitData[9] === "boolean");
      cwt.assert(unitData.length &lt; 11 || typeof unitData[10] === "boolean");

      // copy data into model
      unit = cwt.Unit.getInstance(unitData[0]);
      unit.type = type;
      unit.hp = unitData[4];
      unit.ammo = unitData[5];
      unit.fuel = unitData[6];
      unit.loadedIn = (unitData[7] != cwt.INACTIVE)? cwt.Unit.getInstance(unitData[7]) : null;
      unit.owner = cwt.Player.getInstance(unitData[8]);
      unit.canAct = (typeof unitData[9] === "boolean")? unitData[9] : false;
      unit.hidden = (typeof unitData[10] === "boolean")? unitData[10] : false;
      that.data[unitData[2]][unitData[3]].unit = unit;
    }

    // reset player data
    for (var i = 0, e = cwt.Player.MULTITON_INSTANCES; i &lt; e; i++) {
      var player = cwt.Player.getInstance(i);
      player.name = null;
      player.gold = 0;
      player.manpower = Math.POSITIVE_INFINITY;
      player.team = (i &lt;= data.player - 1) ? i : cwt.NOT_AVAILABLE;
    }

    // grab save game data
    if (isSave) {
      for (var i = 0, e = data.players.length; i &lt; e; i++) {
        var playerData = data.players[i];

        // check_ data
        cwt.assert(playerData[0] >= 0 &amp;&amp; playerData[0] &lt; cwt.Player.MULTITON_INSTANCES);
        cwt.assert(typeof playerData[1] === "string");
        cwt.assert(playerData[3] >= 0 &amp;&amp; playerData[3] &lt; cwt.Player.MULTITON_INSTANCES);
        cwt.assert(playerData[2] >= 0 &amp;&amp; playerData[2] &lt; 999999);
        cwt.assert(playerData[4] >= 0 &amp;&amp; playerData[4] &lt; 999999);

        // set player data
        var player = cwt.Player.getInstance(playerData[0]);
        player.name = playerData[1];
        player.gold = playerData[2];
        player.team = playerData[3];
        player.manpower = playerData[4];
      }
    }
  }

};

/*


 (function () {

 function placeCannonMetaData(x, y) {
 var prop = model.property_posMap[x][y];
 var cannon = prop.type.cannon;
 var size = prop.type.bigProperty;

 cwt.assert(x - size.x >= 0);
 cwt.assert(y - size.y >= 0);

 var ax = x - size.actor[0];
 var ay = y - size.actor[1];
 var ox = x;
 var oy = y;
 for (var xe = x - size.x; x > xe; x--) {

 y = oy;
 for (var ye = y - size.y; y > ye; y--) {

 // place blocker
 if (x !== ox || y !== oy) {
 if (this.DEBUG) util.log("creating invisible property at", x, ",", y);
 model.events.property_createProperty(prop.owner, x, y, "PROP_INV");
 }

 // place actor
 if (x === ax &amp;&amp; y === ay) {
 if (this.DEBUG) util.log("creating cannon unit at", x, ",", y);
 model.events.createUnit(model.unit_getFreeSlot(prop.owner), prop.owner,
 x, y, "CANNON_UNIT_INV");
 }

 }
 }
 }

 // // Places the necessary meta units for bigger properties.
 //
 model.event_on("gameround_start", function () {
 for (var x = 0, xe = model.map_width; x &lt; xe; x++) {
 for (var y = 0, ye = model.map_height; y &lt; ye; y++) {

 var prop = model.property_posMap[x][y];
 if (prop) {

 if (prop.type.bigProperty &amp;&amp; prop.type.cannon) {
 placeCannonMetaData(x, y);
 } else if (prop.type.cannon) {
 if (this.DEBUG) util.log("creating cannon unit at", x, ",", y);
 model.events.createUnit(model.unit_getFreeSlot(prop.owner), prop.owner,
 x, y, "CANNON_UNIT_INV");
 } else if (prop.type.laser) {
 if (this.DEBUG) util.log("creating laser unit at", x, ",", y);
 model.events.createUnit(model.unit_getFreeSlot(prop.owner), prop.owner,
 x, y, "LASER_UNIT_INV");
 }

 }
 }
 }
 });

 })();
 */</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="$base.html">base/$base</a></li></ul><h3>Classes</h3><ul><li><a href="cwt.Action.html">Action</a></li><li><a href="cwt.ActionData.html">ActionData</a></li><li><a href="cwt.CircularBuffer.html">CircularBuffer</a></li><li><a href="cwt.Config.html">Config</a></li><li><a href="cwt.GameState.html">GameState</a></li><li><a href="cwt.Input.html">Input</a></li><li><a href="cwt.InputData.html">InputData</a></li><li><a href="cwt.Layer.html">Layer</a></li><li><a href="cwt.LayeredCanvas.html">LayeredCanvas</a></li><li><a href="cwt.Matrix.html">Matrix</a></li><li><a href="cwt.MovetypeSheet.html">MovetypeSheet</a></li><li><a href="cwt.Pagination.html">Pagination</a></li><li><a href="cwt.Player.html">Player</a></li><li><a href="cwt.Position.html">Position</a></li><li><a href="cwt.Property.html">Property</a></li><li><a href="cwt.html#Sprite">Sprite</a></li><li><a href="cwt.Storage.html">Storage</a></li><li><a href="cwt.Tile.html">Tile</a></li><li><a href="cwt.TileVariantInfo.html">TileVariantInfo</a></li><li><a href="cwt.UIButtonGroup.html">UIButtonGroup</a></li><li><a href="cwt.UICheckboxField.html">UICheckboxField</a></li><li><a href="cwt.UICustomField.html">UICustomField</a></li><li><a href="cwt.UIField.html">UIField</a></li><li><a href="cwt.UIScreenLayout.html">UIScreenLayout</a></li><li><a href="cwt.Unit.html">Unit</a></li></ul><h3>Namespaces</h3><ul><li><a href="cwt.ActionStack.html">ActionStack</a></li><li><a href="cwt.Attack.html">Attack</a></li><li><a href="cwt.Cannon.html">Cannon</a></li><li><a href="cwt.Capture.html">Capture</a></li><li><a href="cwt.ClientEvents.html">ClientEvents</a></li><li><a href="cwt.CO.html">CO</a></li><li><a href="cwt.Cursor.html">Cursor</a></li><li><a href="cwt.Explode.html">Explode</a></li><li><a href="cwt.Factory.html">Factory</a></li><li><a href="cwt.FlowData.menu.html">menu</a></li><li><a href="cwt.Fog.html">Fog</a></li><li><a href="cwt.GameData.html">GameData</a></li><li><a href="cwt.Gameflow.html">Gameflow</a></li><li><a href="cwt.Gameround.html">Gameround</a></li><li><a href="cwt.Image.html">Image</a></li><li><a href="cwt.Join.html">Join</a></li><li><a href="cwt.Laser.html">Laser</a></li><li><a href="cwt.Lifecycle.html">Lifecycle</a></li><li><a href="cwt.Loading.html">Loading</a></li><li><a href="cwt.Localization.html">Localization</a></li><li><a href="cwt.Map.html">Map</a></li><li><a href="cwt.MapRenderer.html">MapRenderer</a></li><li><a href="cwt.Maps.html">Maps</a></li><li><a href="cwt.Move.html">Move</a></li><li><a href="cwt.Network.html">Network</a></li><li><a href="cwt.Options.html">Options</a></li><li><a href="cwt.Relationship.html">Relationship</a></li><li><a href="cwt.Screen.html">Screen</a></li><li><a href="cwt.Silo.html">Silo</a></li><li><a href="cwt.Supply.html">Supply</a></li><li><a href="cwt.Team.html">Team</a></li><li><a href="cwt.Transport.html">Transport</a></li><li><a href="cwt.Turn.html">Turn</a></li><li><a href="cwt.Weather.html">Weather</a></li></ul><h3>Global</h3><ul><li><a href="global.html#background">background</a></li><li><a href="global.html#check_">check_</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#getContext">getContext</a></li><li><a href="global.html#getLayer">getLayer</a></li><li><a href="global.html#isValidSheet">isValidSheet</a></li><li><a href="global.html#registerSheet">registerSheet</a></li><li><a href="global.html#renderLayer">renderLayer</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetValues">resetValues</a></li><li><a href="global.html#sheets">sheets</a></li><li><a href="global.html#types">types</a></li><li><a href="global.html#validator_">validator_</a></li><li><a href="global.html#value[2]">value[2]</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Fri May 16 2014 19:01:55 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
