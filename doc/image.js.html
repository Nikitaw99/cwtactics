<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controller/image.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controller/image.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @namespace
 */
cwt.Image = {

  /**
   * @constant
   */
  IMAGE_KEY: "GFX_",

  /**
   * @constant
   */
  TYPE_UNIT: 0,

  /**
   * @constant
   */
  TYPE_PROPERTY: 1,

  /**
   * @constant
   */
  TYPE_TILE: 2,

  /**
   * @constant
   */
  TYPE_ANIMATED_TILE: 3,

  /**
   * @constant
   */
  TYPE_ANIMATED_TILE_WITH_VARIANTS: 4,

  /**
   * @constant
   */
  TYPE_MISC: 10,

  /**
   * @constant
   */
  TYPE_IMAGE: 99,

  /**
   * Color schema for a unit sprite.
   *
   * @constant
   */
  UNIT_INDEXES: {
    RED: 0,
    BLUE: 3,
    GREEN: 4,
    YELLOW: 5,
    colors: 6
  },

  /**
   * Color schema for a property sprite.
   *
   * @constant
   */
  PROPERTY_INDEXES: {
    RED: 0,
    GRAY: 1,
    BLUE: 3,
    GREEN: 4,
    YELLOW: 5,
    colors: 4
  },

  /**
   * @type {object.&lt;cwt.Sprite>}
   */
  sprites: {},

  overlayTiles: {},

  longAnimatedTiles: {},

  /**
   *
   * @param type
   * @param sprite
   * @param callback
   */
  saveSpriteToCache: function (type, sprite, callback) {
    if (cwt.DEBUG) cwt.assert(sprite instanceof cwt.ArmySprite || sprite instanceof cwt.Sprite);

    // extract data
    var data = (sprite instanceof cwt.ArmySprite) ? cwt.ArmySprite.toJSON(sprite) : cwt.Sprite.toJSON(sprite);

    // save it
    cwt.Storage.assetsStorage.set(type, data, callback);
  },

  /**
   *
   * @param type
   * @param path
   * @param callback
   */
  loadSprite: function (type, path, imgType, callback) {
    cwt.Storage.assetsStorage.get(type, function (obj) {
      if (obj.value) {
        // is in the cache
        this.sprites[type] = this.jSONtoColoredSprite_(obj.value);
        callback();

      } else {
        // not in the cache
        var img = new Image();
        img.src = path;

        img.onload = function () {
          var sprite;

          switch (imgType) {
            case cwt.Image.TYPE_UNIT:
              sprite = cwt.Image.createUnitSprites();
              break;

            case cwt.Image.TYPE_PROPERTY:
              sprite = cwt.Image.createPropertySprites();
              break;

            case cwt.Image.TYPE_TILE:
              sprite = cwt.Image.createTileSprites();
              break;
          }

          // save image in the cache
          cwt.Image.saveSpriteToCache(type, sprite, callback);
        };

        // failed to load the image data
        img.onerror = function () {
          throw Error("could not load image for " + type + " at location " + path);
        };
      }
    });
  },

  createUnitSprites: function () {
    // crop idle, left, up, down

    // flip idle and left

    // colorize all
  },

  createPropertySprites: function () {

    // colorize it
  },

  createTileSprites: function () {
    // crop all tiles
  },

  /**
   *
   * @private
   */
  removeGrabbers_: function () {
    delete cwt.Image.removeGrabbers_;
    delete cwt.Image.grabFromCache;
    delete cwt.Image.grabFromRemote;
  },

  /**
   *
   * @param {Function} callback
   */
  grabFromRemote: function (callback) {
    this.removeGrabbers_(); // remove initializer functions

    function getImageDataArray(image) {
      var canvas = document.createElement("canvas");
      var canvasContext = canvas.getContext("2d");

      var imgW = image.width;
      var imgH = image.height;
      canvas.width = imgW;
      canvas.height = imgH;
      canvasContext.drawImage(image, 0, 0);
      return canvasContext.getImageData(0, 0, imgW, imgH).data;
    }

    /**
     * Changes colors in an assets object by given replacement color maps and returns a new assets
     * object (html5 canvas).
     *
     * @inner
     * @param image
     * @param colorData
     * @param numColors
     * @param oriIndex
     * @param replaceIndex
     * @return {HTMLCanvasElement}
     */
    function replaceColors(image, colorData, numColors, oriIndex, replaceIndex) {
      var canvas = document.createElement("canvas");
      var canvasContext = canvas.getContext("2d");

      // create target canvas
      var imgW = image.width;
      var imgH = image.height;
      canvas.width = imgW;
      canvas.height = imgH;
      canvasContext.drawImage(image, 0, 0);
      var imgPixels = canvasContext.getImageData(0, 0, imgW, imgH);

      var oriStart = (oriIndex * 4) * numColors;
      var replStart = (replaceIndex * 4) * numColors;
      for (var y = 0; y &lt; imgPixels.height; y++) {
        for (var x = 0; x &lt; imgPixels.width; x++) {
          var xi = (y * 4) * imgPixels.width + x * 4;

          var oR = imgPixels.data[xi  ];
          var oG = imgPixels.data[xi + 1];
          var oB = imgPixels.data[xi + 2];
          for (var n = 0, ne = (numColors * 4); n &lt; ne; n += 4) {

            var sR = colorData[oriStart + n  ];
            var sG = colorData[oriStart + n + 1];
            var sB = colorData[oriStart + n + 2];

            if (sR === oR &amp;&amp; sG === oG &amp;&amp; sB === oB) {

              var r = replStart + n;
              var rR = colorData[r  ];
              var rG = colorData[r + 1];
              var rB = colorData[r + 2];
              imgPixels.data[xi  ] = rR;
              imgPixels.data[xi + 1] = rG;
              imgPixels.data[xi + 2] = rB;
            }
          }
        }
      }

      // write changes back
      canvasContext.putImageData(imgPixels, 0, 0);

      return canvas;
    }

    /**
     *
     * @inner
     * @param {HTMLImageElement|HTMLCanvasElement} image
     * @return {HTMLCanvasElement}
     */
    function createBlackMask(image) {
      var canvas = document.createElement("canvas");
      var canvasContext = canvas.getContext("2d");

      // create target canvas
      var imgW = image.width;
      var imgH = image.height;
      canvas.width = imgW;
      canvas.height = imgH;
      canvasContext.drawImage(image, 0, 0);
      var imgPixels = canvasContext.getImageData(0, 0, imgW, imgH);

      for (var y = 0; y &lt; imgPixels.height; y++) {
        for (var x = 0; x &lt; imgPixels.width; x++) {
          var xi = (y * 4) * imgPixels.width + x * 4;
          var oA = imgPixels.data[xi + 3];

          // if pixel is not transparent, then fill it with black
          if (oA > 0) {
            imgPixels.data[xi  ] = 0;
            imgPixels.data[xi + 1] = 0;
            imgPixels.data[xi + 2] = 0;
          }
        }
      }

      // write changes back
      canvasContext.putImageData(imgPixels, 0, 0);

      return canvas;
    }

    /**
     * Draws a part of an image to a new canvas.
     *
     * @inner
     * @param {HTMLImageElement|HTMLCanvasElement} image image object
     * @param {number} sx source x coordinate
     * @param {number} sy source y coordinate
     * @param {number} w width
     * @param {number} h height
     * @return {HTMLCanvasElement}
     */
    function cropImage(image, sx, sy, w, h) {
      var nCanvas = document.createElement('canvas');
      var nContext = nCanvas.getContext('2d');

      nCanvas.width = w;
      nCanvas.height = h;

      nContext.drawImage(image, sx, sy, w, h, 0, 0, w, h);

      return /** @type {HTMLCanvasElement} */ nCanvas;
    }

    /**
     * Flips an image.
     *
     * BASED ON http://jsfiddle.net/pankajparashar/KwDhX/
     *
     * @inner
     * @param {Image|HTMLCanvasElement} image
     * @param {boolean} flipH
     * @param {boolean} flipV
     * @return {HTMLCanvasElement}
     */
    function flipImage(image, flipH, flipV) {
      var scaleH = flipH ? -1 : 1;
      var scaleV = flipV ? -1 : 1;
      var posX = flipH ? image.width * -1 : 0;
      var posY = flipV ? image.height * -1 : 0;

      // target canvas
      var nCanvas = document.createElement('canvas');
      var nContext = nCanvas.getContext('2d');

      nCanvas.height = image.height;
      nCanvas.width = image.width;

      // transform it
      nContext.save();
      nContext.scale(scaleH, scaleV);
      nContext.drawImage(image, posX, posY, image.width, image.height);
      nContext.restore();

      return /** @type {HTMLCanvasElement} */ nCanvas;
    }

    /**
     * Doubles the size of an assets by using the scale2x algorithm.
     *
     * @inner
     * @param image
     * @return {HTMLElement}
     */
    function scale2x(image) {
      var imgW = image.width;
      var imgH = image.height;
      var oR, oG, oB;
      var uR, uG, uB;
      var dR, dG, dB;
      var rR, rG, rB;
      var lR, lG, lB;
      var xi;
      var t0R, t0G, t0B;
      var t1R, t1G, t1B;
      var t2R, t2G, t2B;
      var t3R, t3G, t3B;

      // create target canvas
      var canvasS = document.createElement("canvas");
      var canvasSContext = canvasS.getContext("2d");
      canvasS.width = imgW;
      canvasS.height = imgH;
      canvasSContext.drawImage(image, 0, 0);
      var imgPixelsS = canvasSContext.getImageData(0, 0, imgW, imgH);

      // create target canvas
      var canvasT = document.createElement("canvas");
      var canvasTContext = canvasT.getContext("2d");
      canvasT.width = imgW * 2;
      canvasT.height = imgH * 2;
      var imgPixelsT = canvasTContext.getImageData(0, 0, imgW * 2, imgH * 2);

      // scale it
      for (var y = 0; y &lt; imgPixelsS.height; y++) {
        for (var x = 0; x &lt; imgPixelsS.width; x++) {

          // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          // grab source pixels
          //

          // grab center
          xi = (y * 4) * imgPixelsS.width + x * 4;
          oR = imgPixelsS.data[xi ];
          oG = imgPixelsS.data[xi + 1];
          oB = imgPixelsS.data[xi + 2];

          // grab left
          if (x > 0) {
            xi = (y * 4) * imgPixelsS.width + (x - 1) * 4;
            lR = imgPixelsS.data[xi ];
            lG = imgPixelsS.data[xi + 1];
            lB = imgPixelsS.data[xi + 2];
          }
          else {
            lR = oR;
            lG = oG;
            lB = oB;
          }

          // grab up
          if (y > 0) {
            xi = ((y - 1) * 4) * imgPixelsS.width + (x) * 4;
            uR = imgPixelsS.data[xi ];
            uG = imgPixelsS.data[xi + 1];
            uB = imgPixelsS.data[xi + 2];
          }
          else {
            uR = oR;
            uG = oG;
            uB = oB;
          }

          // grab down
          if (x &lt; imgPixelsS.height - 1) {
            xi = ((y + 1) * 4) * imgPixelsS.width + (x) * 4;
            dR = imgPixelsS.data[xi ];
            dG = imgPixelsS.data[xi + 1];
            dB = imgPixelsS.data[xi + 2];
          }
          else {
            dR = oR;
            dG = oG;
            dB = oB;
          }

          // grab right
          if (x &lt; imgPixelsS.width - 1) {
            xi = (y * 4) * imgPixelsS.width + (x + 1) * 4;
            rR = imgPixelsS.data[xi ];
            rG = imgPixelsS.data[xi + 1];
            rB = imgPixelsS.data[xi + 2];
          }
          else {
            rR = oR;
            rG = oG;
            rB = oB;
          }

          // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          // calculates target pixels
          //

          // E0 = E; E1 = E; E2 = E; E3 = E;
          t0R = oR;
          t0G = oG;
          t0B = oB;
          t1R = oR;
          t1G = oG;
          t1B = oB;
          t2R = oR;
          t2G = oG;
          t2B = oB;
          t3R = oR;
          t3G = oG;
          t3B = oB;

          // if (B != H &amp;&amp; D != F)
          if (( uR !== dR || uG !== dG || uB !== dB ) &amp;&amp; ( lR !== rR || lG !== rG || lB !== rB )) {

            // E0 = D == B ? D : E;
            if (uR === lR &amp;&amp; uG === lG &amp;&amp; uB === lB) {
              t0R = lR;
              t0G = lG;
              t0B = lB;
            }

            // E1 = B == F ? F : E;
            if (uR === rR &amp;&amp; uG === rG &amp;&amp; uB === rB) {
              t1R = rR;
              t1G = rG;
              t1B = rB;
            }

            // E2 = D == H ? D : E;
            if (lR === dR &amp;&amp; lG === dG &amp;&amp; lB === dB) {
              t2R = lR;
              t2G = lG;
              t2B = lB;
            }

            // E3 = H == F ? F : E;
            if (dR === rR &amp;&amp; dG === rG &amp;&amp; dB === rB) {
              t3R = rR;
              t3G = rG;
              t3B = rB;
            }
          }

          // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          // write pixels to target canvas
          //

          xi = ((y * 2) * 4) * imgPixelsT.width + (x * 2) * 4;
          imgPixelsT.data[xi + 0] = t0R;
          imgPixelsT.data[xi + 1] = t0G;
          imgPixelsT.data[xi + 2] = t0B;
          imgPixelsT.data[xi + 4] = t1R;
          imgPixelsT.data[xi + 5] = t1G;
          imgPixelsT.data[xi + 6] = t1B;

          xi = ((y * 2 + 1) * 4) * imgPixelsT.width + (x * 2) * 4;
          imgPixelsT.data[xi + 0] = t2R;
          imgPixelsT.data[xi + 1] = t2G;
          imgPixelsT.data[xi + 2] = t2B;
          imgPixelsT.data[xi + 4] = t3R;
          imgPixelsT.data[xi + 5] = t3G;
          imgPixelsT.data[xi + 6] = t3B;
        }
      }

      // write changes back to the canvas
      canvasTContext.putImageData(imgPixelsT, 0, 0);

      canvasS = null;
      return canvasT;
    }

    /**
     *
     * @inner
     * @param sprite
     * @param state
     * @param rImg
     * @param bImg
     * @param gImg
     * @param yImg
     * @param startX
     */
    function cropUnitState(sprite, state, rImg, bImg, gImg, yImg, startX) {
      sprite.setImage(cwt.Sprite.UNIT_RED + state, cropImage(rImg, startX, 0, 96, 32));
      sprite.setImage(cwt.Sprite.UNIT_BLUE + state, cropImage(bImg, startX, 0, 96, 32));
      sprite.setImage(cwt.Sprite.UNIT_GREEN + state, cropImage(gImg, startX, 0, 96, 32));
      sprite.setImage(cwt.Sprite.UNIT_YELLOW + state, cropImage(yImg, startX, 0, 96, 32));
      sprite.setImage(cwt.Sprite.UNIT_SHADOW_MASK + state,
        createBlackMask(sprite.getImage(cwt.Sprite.UNIT_RED + state)));
    }

    /**
     *
     * @inner
     * @param sprite
     * @param state
     * @param rImg
     * @param bImg
     * @param gImg
     * @param yImg
     * @param startX
     */
    function cropUnitStateInverted(sprite, state, rImg, bImg, gImg, yImg, startX) {
      // TODO: bug flips whole image, but it would be correct to flip every state
      sprite.setImage(cwt.Sprite.UNIT_RED + state, flipImage(cropImage(rImg, startX, 0, 96, 32), true, false));
      sprite.setImage(cwt.Sprite.UNIT_BLUE + state, flipImage(cropImage(bImg, startX, 0, 96, 32), true, false));
      sprite.setImage(cwt.Sprite.UNIT_GREEN + state, flipImage(cropImage(gImg, startX, 0, 96, 32), true, false));
      sprite.setImage(cwt.Sprite.UNIT_YELLOW + state, flipImage(cropImage(yImg, startX, 0, 96, 32), true, false));
      sprite.setImage(cwt.Sprite.UNIT_SHADOW_MASK + state,
        createBlackMask(sprite.getImage(cwt.Sprite.UNIT_RED + state)));
    }

    function cropAndRotate(image, sx, sy, w, rotation) {
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      var hw = w / 2;
      if (cwt.DEBUG) cwt.assert(hw % 1 === 0);

      canvas.height = w;
      canvas.width = w;

      // transform
      context.save();
      context.translate(hw, hw);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-hw, -hw);

      // draw
      context.drawImage(image, sx, sy, w, w, 0, 0, w, w);

      context.restore();

      return canvas;
    }

    function grabImage(path, key, callback) {
      if (cwt.DEBUG) {
        console.log("going to load image " + path + " for key " + key);
      }

      var image = new Image();

      if (cwt.DEBUG) {
        image.onload = function () {
          console.log("successfully loaded image " + path + " for key " + key);
          callback.apply(this, arguments);
        };
      } else {
        image.onload = callback;
      }


      image.src = cwt.MOD_PATH + path;
      image.key = key;
    }

    // ------------------------------------------------------------------------

    var unitColorData;
    var propertyColorData;
    var unitColStat = cwt.Image.UNIT_INDEXES;
    var propColStat = cwt.Image.PROPERTY_INDEXES;

    var stuff = [];

    function addToPushLoop(path, key, callback) {
      stuff.push(function (next) {
        grabImage(path, key, function () {
          callback(this, next);
        });
      })
    }

    // grab color map images
    stuff.push(
      function (next) {
        grabImage(cwt.Graphics.COLOR_MAP[0], null, function () {
          propertyColorData = getImageDataArray(this);
          next();
        });
      },
      function (next) {
        grabImage(cwt.Graphics.COLOR_MAP[1], null, function () {
          unitColorData = getImageDataArray(this);
          next();
        });
      }
    );

    // grab unit images
    Object.keys(cwt.Graphics.UNITS).forEach(function (key) {
      stuff.push(function (next) {
        var path = cwt.Graphics.UNITS[key];
        grabImage(path, key, function () {
          var sprite = new cwt.Sprite(cwt.Sprite.UNIT_STATES);

          var red = /** @type {HTMLImageElement} */ this;
          var blue;
          var green;
          var yellow;

          // create colored sprite maps
          blue = replaceColors(red, unitColorData, unitColStat.colors, unitColStat.RED, unitColStat.BLUE);
          green = replaceColors(red, unitColorData, unitColStat.colors, unitColStat.RED, unitColStat.GREEN);
          yellow = replaceColors(red, unitColorData, unitColStat.colors, unitColStat.RED, unitColStat.YELLOW);

          // crop out target states as single images
          cropUnitState(sprite, cwt.Sprite.UNIT_STATE_IDLE, red, blue, green, yellow, 0);
          cropUnitState(sprite, cwt.Sprite.UNIT_STATE_UP, red, blue, green, yellow, 96);
          cropUnitState(sprite, cwt.Sprite.UNIT_STATE_DOWN, red, blue, green, yellow, 192);
          cropUnitState(sprite, cwt.Sprite.UNIT_STATE_LEFT, red, blue, green, yellow, 288);
          cropUnitStateInverted(sprite, cwt.Sprite.UNIT_STATE_IDLE_INVERTED, red, blue, green, yellow, 0);
          cropUnitStateInverted(sprite, cwt.Sprite.UNIT_STATE_RIGHT, red, blue, green, yellow, 288);

          // register sprite
          cwt.Image.sprites[this.key] = sprite;
          next();
        });
      });
    });

    // grab tile images
    Object.keys(cwt.Graphics.TILES).forEach(function (key) {
      var value = cwt.Graphics.TILES[key];
      var sprite;

      // special graphic data for tiles
      if (value[value.length - 2] === true) {
        cwt.Image.longAnimatedTiles[key] = true;
      }
      if (value[value.length - 1] === true) {
        cwt.Image.overlayTiles[key] = true;
      }

      if (value.length === 3) { // single variant tile
        sprite = new cwt.Sprite(cwt.Sprite.TILE_STATES);
        stuff.push(function (next) {
          grabImage(value[0], key, function () {
            sprite.setImage(0, /** @type {HTMLImageElement}*/ this);
            sprite.setImage(1,createBlackMask(this));
            next();
          });
        });

      } else {                  // multi variant tile
        sprite = new cwt.Sprite(value[2].length*cwt.Sprite.TILE_STATES);

        cwt.TileVariants.registerVariantInfo(key, value[0], value[1]);

        for (var i = 0, e = value[2].length; i &lt; e; i++) {
          addToPushLoop(value[2][i], i*2, function (img, next) {
            sprite.setImage(img.key, img);
            sprite.setImage(img.key+1,createBlackMask(img));
            next();
          });
        }
      }

      cwt.Image.sprites[key] = sprite;
    });

    // grab property images
    Object.keys(cwt.Graphics.PROPERTIES).forEach(function (key) {
      stuff.push(function (next) {
        var path = cwt.Graphics.PROPERTIES[key];
        grabImage(path, key, function () {
          var sprite = new cwt.Sprite(cwt.Sprite.PROPERTY_STATES);

          var red = /** @type {HTMLImageElement} */ this;
          var blue;
          var green;
          var yellow;
          var neutral;
          var shadow;

          blue = replaceColors(red, propertyColorData, propColStat.colors, propColStat.RED, propColStat.BLUE);
          green = replaceColors(red, propertyColorData, propColStat.colors, propColStat.RED, propColStat.GREEN);
          yellow = replaceColors(red, propertyColorData, propColStat.colors, propColStat.RED, propColStat.YELLOW);
          neutral = replaceColors(red, propertyColorData, propColStat.colors, propColStat.RED, propColStat.GRAY);
          shadow = createBlackMask(red);

          sprite.setImage(cwt.Sprite.PROPERTY_RED, red);
          sprite.setImage(cwt.Sprite.PROPERTY_BLUE, blue);
          sprite.setImage(cwt.Sprite.PROPERTY_GREEN, green);
          sprite.setImage(cwt.Sprite.PROPERTY_YELLOW, yellow);
          sprite.setImage(cwt.Sprite.PROPERTY_NEUTRAL, neutral);
          sprite.setImage(cwt.Sprite.PROPERTY_SHADOW_MASK, shadow);

          // register sprite
          cwt.Image.sprites[this.key] = sprite;
          next();
        });
      });
    });

    // grab arrow images
    stuff.push(function (next) {
      var path = cwt.Graphics.ARROW;
      grabImage(path, "ARROW", function () {
        var sprite = new cwt.Sprite(10);

        var arrowMap = /** @type {HTMLImageElement} */ this;

        sprite.setImage(cwt.Sprite.DIRECTION_N, cropImage(arrowMap, 0, 0, 16, 16));
        sprite.setImage(cwt.Sprite.DIRECTION_S, cropAndRotate(arrowMap, 0, 0, 16, 180));
        sprite.setImage(cwt.Sprite.DIRECTION_W, cropAndRotate(arrowMap, 0, 0, 16, 270));
        sprite.setImage(cwt.Sprite.DIRECTION_E, cropAndRotate(arrowMap, 0, 0, 16, 90));
        sprite.setImage(cwt.Sprite.DIRECTION_SW, cropAndRotate(arrowMap, 32, 0, 16, 90));
        sprite.setImage(cwt.Sprite.DIRECTION_SE, cropImage(arrowMap, 32, 0, 16, 16));
        sprite.setImage(cwt.Sprite.DIRECTION_NW, cropAndRotate(arrowMap, 32, 0, 16, 180));
        sprite.setImage(cwt.Sprite.DIRECTION_NE, cropAndRotate(arrowMap, 32, 0, 16, 270));
        sprite.setImage(cwt.Sprite.DIRECTION_NS, cropImage(arrowMap, 16, 0, 16, 16));
        sprite.setImage(cwt.Sprite.DIRECTION_WE, cropAndRotate(arrowMap, 16, 0, 16, 90));

        // register sprite
        cwt.Image.sprites[this.key] = sprite;
        next();
      });
    });

    // grab dust images
    stuff.push(function (next) {
      var path = cwt.Graphics.DUST;
      grabImage(path, "DUST", function () {
        var sprite = new cwt.Sprite(4);

        var imgMap = /** @type {HTMLImageElement} */ this;

        sprite.setImage(cwt.Sprite.DIRECTION_LEFT, cropImage(imgMap, 0, 0, 96, 32));
        sprite.setImage(cwt.Sprite.DIRECTION_UP, cropImage(imgMap, 96, 0, 96, 32));
        sprite.setImage(cwt.Sprite.DIRECTION_DOWN, cropImage(imgMap, 192, 0, 96, 32));
        sprite.setImage(cwt.Sprite.DIRECTION_RIGHT, cropImage(imgMap, 288, 0, 96, 32));

        // register sprite
        cwt.Image.sprites[this.key] = sprite;
        next();
      });
    });

    // grab rocket fly images
    stuff.push(function (next) {
      var path = cwt.Graphics.ROCKET_FLY;
      grabImage(path, "ROCKET_FLY", function () {
        var sprite = new cwt.Sprite(2);

        sprite.setImage(cwt.Sprite.DIRECTION_UP, /** @type {HTMLImageElement} */ this);
        sprite.setImage(cwt.Sprite.DIRECTION_DOWN, cropAndRotate(this, 0, 0, 24, 180));

        // register sprite
        cwt.Image.sprites[this.key] = sprite;
        next();
      });
    });

    // grab other images
    Object.keys(cwt.Graphics.OTHERS).forEach(function (key) {
      var value = cwt.Graphics.OTHERS[key];
      var sprite;

      if (typeof value === "string") {
        sprite = new cwt.Sprite(1);

        stuff.push(function (next) {      // single image sprite
          grabImage(value, key, function () {
            sprite.setImage(0, this);
            cwt.Image.sprites[this.key] = sprite;
            next();
          });
        });
      } else {                            // multi image sprite
        sprite = new cwt.Sprite(value.length);

        for (var i = 0, e = value.length; i &lt; e; i++) {
          addToPushLoop(value[i], i, function (img, next) {
            sprite.setImage(img.key, img);
            next();
          });
        }
      }

      cwt.Image.sprites[key] = sprite;
    });

    callAsSequence(stuff, function () {
      delete cwt.Graphics;
      callback();
    });
  },

  /**
   *
   * @param callback
   */
  persistImages: function (callback) {
    if (cwt.DEBUG) {
      console.log("persist all images in the cache");
    }

    var stuff = [];

    Object.keys(cwt.Image.sprites).forEach(function (key) {
      var sprite = cwt.Image.sprites[key];
      stuff.push(function (next) {
        cwt.Storage.assetsStorage.set(
          cwt.Image.IMAGE_KEY+key,
          cwt.Sprite.toJSON(cwt.Image.sprites[key]),
          function () {
            next();
          }
        )
      });
    });

    callAsSequence(stuff, function () {
      if (cwt.DEBUG) {
        console.log("completed image persist process");
      }

      callback();
    });
  },


  /**
   *
   * @param {Function} callback
   */
  grabFromCache: function (callback) {
    this.removeGrabbers_(); // remove initializer functions

    var stuff = [];

    /**
     * @inner
     * @param key
     */
    function loadKey(key) {
      var realKey = key.slice(cwt.Image.IMAGE_KEY.length);
      stuff.push(function (next) {
        if (cwt.DEBUG) {
          console.log("grab sprite "+key+" from cache");
        }

        cwt.Storage.assetsStorage.get(key, function (obj) {
          if (cwt.DEBUG) cwt.assert(obj.value);

          cwt.Image.sprites[realKey] = cwt.Sprite.fromJSON(obj.value);

          next();
        });
      })
    }

    // load all possible audio (except music) keys from the storage into the RAM
    cwt.Storage.assetsStorage.keys(function (keys) {
      for (var i = 0, e = keys.length; i &lt; e; i++) {
        var key = keys[i];
        if (key.indexOf(cwt.Image.IMAGE_KEY) === 0) {
          loadKey(key);
        }
      }

      // grab tile variant information
      Object.keys(cwt.Graphics.TILES).forEach(function (key) {
        var value = cwt.Graphics.TILES[key];

        // special graphic data for tiles
        if (value[value.length - 2] === true) {
          cwt.Image.longAnimatedTiles[key] = true;
        }
        if (value[value.length - 1] === true) {
          cwt.Image.overlayTiles[key] = true;
        }

        if (value.length !== 3) { // multi variant tile
          cwt.TileVariants.registerVariantInfo(key, value[0], value[1]);
        }
      });

      callAsSequence(stuff, function () {
        callback();
      });
    });
  }

};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="$base.html">base/$base</a></li></ul><h3>Classes</h3><ul><li><a href="cwt.Action.html">Action</a></li><li><a href="cwt.ActionData.html">ActionData</a></li><li><a href="cwt.CircularBuffer.html">CircularBuffer</a></li><li><a href="cwt.Config.html">Config</a></li><li><a href="cwt.GameState.html">GameState</a></li><li><a href="cwt.Input.html">Input</a></li><li><a href="cwt.InputData.html">InputData</a></li><li><a href="cwt.Layer.html">Layer</a></li><li><a href="cwt.LayeredCanvas.html">LayeredCanvas</a></li><li><a href="cwt.Matrix.html">Matrix</a></li><li><a href="cwt.MovetypeSheet.html">MovetypeSheet</a></li><li><a href="cwt.Pagination.html">Pagination</a></li><li><a href="cwt.Player.html">Player</a></li><li><a href="cwt.Position.html">Position</a></li><li><a href="cwt.Property.html">Property</a></li><li><a href="cwt.html#Sprite">Sprite</a></li><li><a href="cwt.Storage.html">Storage</a></li><li><a href="cwt.Tile.html">Tile</a></li><li><a href="cwt.TileVariantInfo.html">TileVariantInfo</a></li><li><a href="cwt.UIButtonGroup.html">UIButtonGroup</a></li><li><a href="cwt.UICheckboxField.html">UICheckboxField</a></li><li><a href="cwt.UICustomField.html">UICustomField</a></li><li><a href="cwt.UIField.html">UIField</a></li><li><a href="cwt.UIScreenLayout.html">UIScreenLayout</a></li><li><a href="cwt.Unit.html">Unit</a></li></ul><h3>Namespaces</h3><ul><li><a href="cwt.ActionStack.html">ActionStack</a></li><li><a href="cwt.Attack.html">Attack</a></li><li><a href="cwt.Cannon.html">Cannon</a></li><li><a href="cwt.Capture.html">Capture</a></li><li><a href="cwt.ClientEvents.html">ClientEvents</a></li><li><a href="cwt.CO.html">CO</a></li><li><a href="cwt.Cursor.html">Cursor</a></li><li><a href="cwt.Explode.html">Explode</a></li><li><a href="cwt.Factory.html">Factory</a></li><li><a href="cwt.FlowData.menu.html">menu</a></li><li><a href="cwt.Fog.html">Fog</a></li><li><a href="cwt.GameData.html">GameData</a></li><li><a href="cwt.Gameflow.html">Gameflow</a></li><li><a href="cwt.Gameround.html">Gameround</a></li><li><a href="cwt.Image.html">Image</a></li><li><a href="cwt.Join.html">Join</a></li><li><a href="cwt.Laser.html">Laser</a></li><li><a href="cwt.Lifecycle.html">Lifecycle</a></li><li><a href="cwt.Loading.html">Loading</a></li><li><a href="cwt.Localization.html">Localization</a></li><li><a href="cwt.Map.html">Map</a></li><li><a href="cwt.MapRenderer.html">MapRenderer</a></li><li><a href="cwt.Maps.html">Maps</a></li><li><a href="cwt.Move.html">Move</a></li><li><a href="cwt.Network.html">Network</a></li><li><a href="cwt.Options.html">Options</a></li><li><a href="cwt.Relationship.html">Relationship</a></li><li><a href="cwt.Screen.html">Screen</a></li><li><a href="cwt.Silo.html">Silo</a></li><li><a href="cwt.Supply.html">Supply</a></li><li><a href="cwt.Team.html">Team</a></li><li><a href="cwt.Transport.html">Transport</a></li><li><a href="cwt.Turn.html">Turn</a></li><li><a href="cwt.Weather.html">Weather</a></li></ul><h3>Global</h3><ul><li><a href="global.html#background">background</a></li><li><a href="global.html#check_">check_</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#getContext">getContext</a></li><li><a href="global.html#getLayer">getLayer</a></li><li><a href="global.html#isValidSheet">isValidSheet</a></li><li><a href="global.html#registerSheet">registerSheet</a></li><li><a href="global.html#renderLayer">renderLayer</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetValues">resetValues</a></li><li><a href="global.html#sheets">sheets</a></li><li><a href="global.html#types">types</a></li><li><a href="global.html#validator_">validator_</a></li><li><a href="global.html#value[2]">value[2]</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Fri May 16 2014 19:01:55 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
